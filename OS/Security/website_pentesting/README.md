# Website Pentesting

## Table of Contents

- [Introduction](#introduction)
- [Pages](#pages)
- [Various things to order](#various-things-to-order)
  - [One liners web server](#one-liners-web-server)
    - [HTTP](#http)
      - [Python 2.X](#python-2x)
      - [Python 3.X](#python-3x)
    - [HTTPS](#https)

## Introduction

Tips and tricks about Website Penetration Testing

To try out website penetration testings, the ideal operating system to do this on is the `Metasploitable Operating System`. This is an Operating  System made with on purpose full of vulnerabilities, not only the system,  but also the extra tools they have installed on it. This is to test out and exercise.

https://sourceforge.net/projects/metasploitable/files/Metasploitable2/

## Pages

Currently, the following topics:

* [dirb](dirb.md) - A tool to scan in a website and find out all files that we are normally not able to visit or be aware of it. It works based on a wordlist file. Usage example: dirb http://10.0.2.7/mutillidae -o dirb_output
* [weevely](weevely.md) - Abuse File Upload Vulnerabilities. A tool to create a PHP backdoor and try to obtain a shell trough a php script.
* `dirbuster` - Similar to dirb but with a cooler name, and with a user interface.
* `gobuster` - Directory/file & DNS busting tool written in Go
* `nikto` - web server security scanner - nikto is a popular web scanning tool that allows users to find common web vulnerabilities. It is commonly used to check for common CVE's such as shellshock, and to get general information about the web server that you're enumerating.

## Various things to order

    ## Post a file with curl

Send the file directly to the upload point. Why use the webpage with the filter, when you can send the file directly using a tool like curl? Posting the data directly to the page which contains the code for handling the file upload is another effective method for completely bypassing a client side filter. We will not be covering this method in any real depth in this tutorial, however, the syntax for such a command would look something like this: `curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>`. To use this method you would first aim to intercept a successful upload (using Burpsuite or the browser console) to see the parameters being used in the upload, which can then be slotted into the above command.

```comandline
curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>
```

## One liners web server

### HTTP

#### Python 2.X

    python -m SimpleHTTPServer 8000

#### Python 3.X

A simple HTTP server which will start for localhost:

    python3 -m http.server

You can bind it to another ip and port if needed:    

    python -m http.server 8000 --bind 127.0.0.1

See here the python documentation:

https://docs.python.org/3/library/http.server.htmlhttps://docs.python.org/3/library/http.server.html

### HTTPS

Create the required certifications:

```
openssl req -newkey rsa:2048 -nodes -x509 -subj '/CN=name-you-want.example.com' -days 3650 -out server.cert -keyout server.key
openssl s_server -accept 7781 -cert server.cert -key server.key -WWW
```

Then when the certification is ready

```
sbcl --eval '(progn
  (and nil #.(require "hunchentoot")) 
  (setq hunchentoot:*dispatch-table* 
        (list (hunchentoot:create-folder-dispatcher-and-handler "/" "'`pwd`/'"))) 
  (hunchentoot:start (make-instance (quote hunchentoot:easy-ssl-acceptor) 
                                    :port 8443
                                    :ssl-privatekey-file "../cert.key"
                                    :ssl-certificate-file "../cert.crt")))'
```
